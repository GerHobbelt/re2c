/* Generated by re2c 3.0 */
#line 1 "../src/parse/syntax_lexer.re"
#include <stdint.h>

#include "src/msg/msg.h"
#include "src/parse/input.h"
#include "src/parse/syntax_parser.h"
#include "src/util/string_utils.h"

#define YYFILL(n) do { \
    if (!fill(n)) RET_FAIL(error_at_cur("unexpected end of input in configuration")); \
} while(0)

#line 26 "../src/parse/syntax_lexer.re"


namespace re2c {

#line 20 "src/parse/syntax_lexer.cc"
size_t LexerState::maxfill_syntax() { return 6; }
#line 30 "../src/parse/syntax_lexer.re"


#define RET_TOK(t) do { token = t; return Ret::OK; } while(0)

Ret Input::lex_syntax_token(STX_STYPE* yylval, Opt& opts, int& token) {
    const uint8_t* p;
    
#line 30 "src/parse/syntax_lexer.cc"
const uint8_t* yyt1;
#line 36 "../src/parse/syntax_lexer.re"


start:
    tok = cur;
    location = cur_loc();

#line 39 "src/parse/syntax_lexer.cc"
{
	uint8_t yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 144,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		144, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 192, 192, 128, 
		224, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 128, 128, 128, 128, 128, 128, 
		128, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 128, 128, 128, 128, 192, 
		128, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if ((lim - cur) < 6) YYFILL(6);
	yych = *cur;
	if (yybm[0+yych] & 16) {
		goto yy4;
	}
	if (yych <= '>') {
		if (yych <= ')') {
			if (yych <= '\n') {
				if (yych <= 0x00) goto yy1;
				if (yych <= 0x08) goto yy2;
				goto yy5;
			} else {
				if (yych == '"') goto yy6;
				if (yych <= '\'') goto yy2;
				goto yy7;
			}
		} else {
			if (yych <= '.') {
				if (yych <= '+') goto yy2;
				if (yych <= ',') goto yy7;
				if (yych <= '-') goto yy8;
				goto yy2;
			} else {
				if (yych <= '/') goto yy9;
				if (yych <= '9') goto yy10;
				if (yych <= ';') goto yy7;
				goto yy2;
			}
		}
	} else {
		if (yych <= '_') {
			if (yych <= '[') {
				if (yych <= '?') goto yy7;
				if (yych <= '@') goto yy2;
				if (yych <= 'Z') goto yy11;
				goto yy7;
			} else {
				if (yych == ']') goto yy7;
				if (yych <= '^') goto yy2;
				goto yy11;
			}
		} else {
			if (yych <= 'z') {
				if (yych <= '`') goto yy2;
				if (yych == 'c') goto yy14;
				goto yy11;
			} else {
				if (yych == '|') goto yy2;
				if (yych <= '}') goto yy7;
				goto yy2;
			}
		}
	}
yy1:
	++cur;
#line 42 "../src/parse/syntax_lexer.re"
	{ RET_TOK(STX_EOF); }
#line 134 "src/parse/syntax_lexer.cc"
yy2:
	++cur;
yy3:
#line 72 "../src/parse/syntax_lexer.re"
	{ RET_FAIL(error_at_tok("unexpected character: '%c'", cur[-1])); }
#line 140 "src/parse/syntax_lexer.cc"
yy4:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yybm[0+yych] & 16) {
		goto yy4;
	}
#line 47 "../src/parse/syntax_lexer.re"
	{ goto start; }
#line 150 "src/parse/syntax_lexer.cc"
yy5:
	++cur;
#line 43 "../src/parse/syntax_lexer.re"
	{
        next_line();
        goto start;
    }
#line 158 "src/parse/syntax_lexer.cc"
yy6:
	++cur;
#line 70 "../src/parse/syntax_lexer.re"
	{ goto str; }
#line 163 "src/parse/syntax_lexer.cc"
yy7:
	++cur;
#line 71 "../src/parse/syntax_lexer.re"
	{ RET_TOK(cur[-1]); }
#line 168 "src/parse/syntax_lexer.cc"
yy8:
	yych = *++cur;
	if (yybm[0+yych] & 32) {
		goto yy10;
	}
	goto yy3;
yy9:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych == '/') goto yy15;
	goto yy3;
yy10:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yybm[0+yych] & 32) {
		goto yy10;
	}
#line 64 "../src/parse/syntax_lexer.re"
	{
        if (s_to_i32_unsafe(tok, cur, yylval->num)) {
            RET_TOK(STX_NUMBER);
        }
        RET_FAIL(error_at_tok("configuration value overflow"));
    }
#line 194 "src/parse/syntax_lexer.cc"
yy11:
	yyaccept = 1;
	mar = ++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
yy12:
	if (yybm[0+yych] & 64) {
		goto yy11;
	}
	if (yych <= 0x1F) {
		if (yych == '\t') {
			yyt1 = cur;
			goto yy17;
		}
	} else {
		if (yych <= ' ') {
			yyt1 = cur;
			goto yy17;
		}
		if (yych == '=') {
			yyt1 = cur;
			goto yy18;
		}
	}
yy13:
#line 60 "../src/parse/syntax_lexer.re"
	{
        yylval->str = newcstr(tok, cur, alc);
        RET_TOK(STX_NAME);
    }
#line 225 "src/parse/syntax_lexer.cc"
yy14:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == 'o') goto yy19;
	goto yy12;
yy15:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yybm[0+yych] & 128) {
		goto yy15;
	}
	if (yych >= 0x01) goto yy5;
yy16:
	cur = mar;
	if (yyaccept == 0) {
		goto yy3;
	} else {
		goto yy13;
	}
yy17:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy17;
		goto yy16;
	} else {
		if (yych <= ' ') goto yy17;
		if (yych != '=') goto yy16;
	}
yy18:
	++cur;
	p = yyt1;
#line 56 "../src/parse/syntax_lexer.re"
	{
        yylval->str = newcstr(tok, p, alc);
        RET_TOK(STX_CONF);
    }
#line 265 "src/parse/syntax_lexer.cc"
yy19:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == 'd') goto yy20;
	if (yych == 'n') goto yy21;
	goto yy12;
yy20:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == 'e') goto yy22;
	goto yy12;
yy21:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == 'f') goto yy23;
	goto yy12;
yy22:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == ':') goto yy24;
	goto yy12;
yy23:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == ':') goto yy25;
	goto yy12;
yy24:
	yych = *++cur;
	if (yych <= '^') {
		if (yych <= '@') goto yy16;
		if (yych <= 'Z') goto yy26;
		goto yy16;
	} else {
		if (yych == '`') goto yy16;
		if (yych <= 'z') goto yy26;
		goto yy16;
	}
yy25:
	++cur;
#line 48 "../src/parse/syntax_lexer.re"
	{
        CHECK_RET(lex_conf(opts));
        goto start;
    }
#line 310 "src/parse/syntax_lexer.cc"
yy26:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yych <= '9') {
		if (yych <= ' ') {
			if (yych == '\t') {
				yyt1 = cur;
				goto yy27;
			}
			if (yych <= 0x1F) goto yy16;
			yyt1 = cur;
		} else {
			if (yych <= ',') goto yy16;
			if (yych == '/') goto yy16;
			goto yy26;
		}
	} else {
		if (yych <= 'Z') {
			if (yych == '=') {
				yyt1 = cur;
				goto yy28;
			}
			if (yych <= '@') goto yy16;
			goto yy26;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy16;
				goto yy26;
			} else {
				if (yych <= '`') goto yy16;
				if (yych <= 'z') goto yy26;
				goto yy16;
			}
		}
	}
yy27:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy27;
		goto yy16;
	} else {
		if (yych <= ' ') goto yy27;
		if (yych != '=') goto yy16;
	}
yy28:
	++cur;
	p = yyt1;
#line 52 "../src/parse/syntax_lexer.re"
	{
        yylval->str = newcstr(tok, p, alc);
        RET_TOK(STX_CONF_CODE);
    }
#line 366 "src/parse/syntax_lexer.cc"
}
#line 73 "../src/parse/syntax_lexer.re"


str: 
#line 372 "src/parse/syntax_lexer.cc"
{
	uint8_t yych;
	if ((lim - cur) < 4) YYFILL(4);
	yych = *cur;
	if (yych <= '!') {
		if (yych <= 0x00) goto yy30;
		if (yych != '\n') goto yy32;
	} else {
		if (yych <= '"') goto yy33;
		if (yych == '\\') goto yy34;
		goto yy32;
	}
yy30:
	++cur;
yy31:
#line 92 "../src/parse/syntax_lexer.re"
	{
        tok = cur - 1;
        RET_FAIL(error_at_tok("syntax error in string literal"));
    }
#line 393 "src/parse/syntax_lexer.cc"
yy32:
	++cur;
#line 86 "../src/parse/syntax_lexer.re"
	{ tmp_str += static_cast<char>(cur[-1]); goto str; }
#line 398 "src/parse/syntax_lexer.cc"
yy33:
	++cur;
#line 87 "../src/parse/syntax_lexer.re"
	{
        yylval->str = copystr(tmp_str, alc);
        tmp_str.clear();
        RET_TOK(STX_STRING);
    }
#line 407 "src/parse/syntax_lexer.cc"
yy34:
	yych = *(mar = ++cur);
	if (yych <= 'm') {
		if (yych <= '`') {
			if (yych <= '"') {
				if (yych <= '!') goto yy31;
			} else {
				if (yych == '\\') goto yy35;
				goto yy31;
			}
		} else {
			if (yych <= 'b') {
				if (yych <= 'a') goto yy36;
				goto yy37;
			} else {
				if (yych == 'f') goto yy38;
				goto yy31;
			}
		}
	} else {
		if (yych <= 't') {
			if (yych <= 'q') {
				if (yych <= 'n') goto yy39;
				goto yy31;
			} else {
				if (yych <= 'r') goto yy40;
				if (yych <= 's') goto yy31;
				goto yy41;
			}
		} else {
			if (yych <= 'v') {
				if (yych <= 'u') goto yy31;
				goto yy42;
			} else {
				if (yych == 'x') goto yy43;
				goto yy31;
			}
		}
	}
	++cur;
#line 77 "../src/parse/syntax_lexer.re"
	{ tmp_str += '"'; goto str; }
#line 450 "src/parse/syntax_lexer.cc"
yy35:
	++cur;
#line 76 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\\'; goto str; }
#line 455 "src/parse/syntax_lexer.cc"
yy36:
	++cur;
#line 78 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\a'; goto str; }
#line 460 "src/parse/syntax_lexer.cc"
yy37:
	++cur;
#line 79 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\b'; goto str; }
#line 465 "src/parse/syntax_lexer.cc"
yy38:
	++cur;
#line 80 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\f'; goto str; }
#line 470 "src/parse/syntax_lexer.cc"
yy39:
	++cur;
#line 81 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\n'; goto str; }
#line 475 "src/parse/syntax_lexer.cc"
yy40:
	++cur;
#line 82 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\r'; goto str; }
#line 480 "src/parse/syntax_lexer.cc"
yy41:
	++cur;
#line 83 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\t'; goto str; }
#line 485 "src/parse/syntax_lexer.cc"
yy42:
	++cur;
#line 84 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\v'; goto str; }
#line 490 "src/parse/syntax_lexer.cc"
yy43:
	yych = *++cur;
	if (yych <= '/') goto yy44;
	if (yych <= '9') goto yy45;
yy44:
	cur = mar;
	goto yy31;
yy45:
	yych = *++cur;
	if (yych <= '/') goto yy44;
	if (yych >= ':') goto yy44;
	++cur;
#line 85 "../src/parse/syntax_lexer.re"
	{ tmp_str += static_cast<char>(unesc_hex(cur - 4, cur)); goto str; }
#line 505 "src/parse/syntax_lexer.cc"
}
#line 96 "../src/parse/syntax_lexer.re"

    UNREACHABLE();
    return Ret::FAIL; // unreachable
}

#undef RET_TOK

} // namespace re2c
