/* Generated by re2c 3.0 */
#line 1 "../src/parse/syntax_lexer.re"
#include <stdint.h>

#include "src/msg/msg.h"
#include "src/parse/input.h"
#include "src/parse/syntax_parser.h"
#include "src/util/string_utils.h"

#define YYFILL(n) do { \
    if (!fill(n)) { \
        error_at_cur("unexpected end of input in configuration"); \
        return STX_error; \
    } \
} while(0)

#line 29 "../src/parse/syntax_lexer.re"


namespace re2c {

int Input::lex_syntax_token(STX_STYPE* yylval) {
    const uint8_t* p;
    
#line 26 "src/parse/syntax_lexer.cc"
const uint8_t* yyt1;
#line 35 "../src/parse/syntax_lexer.re"


start:
    tok = cur;
    location = cur_loc();

#line 35 "src/parse/syntax_lexer.cc"
{
	uint8_t yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 144,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		144, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 192, 192, 128, 
		224, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 128, 128, 128, 128, 128, 128, 
		128, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 128, 128, 128, 128, 192, 
		128, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if ((lim - cur) < 6) YYFILL(6);
	yych = *cur;
	if (yybm[0+yych] & 16) {
		goto yy4;
	}
	if (yych <= '>') {
		if (yych <= ')') {
			if (yych <= '\n') {
				if (yych <= 0x00) goto yy1;
				if (yych <= 0x08) goto yy2;
				goto yy5;
			} else {
				if (yych == '"') goto yy6;
				if (yych <= '\'') goto yy2;
				goto yy7;
			}
		} else {
			if (yych <= '.') {
				if (yych <= '+') goto yy2;
				if (yych <= ',') goto yy7;
				if (yych <= '-') goto yy8;
				goto yy2;
			} else {
				if (yych <= '/') goto yy9;
				if (yych <= '9') goto yy10;
				if (yych <= ';') goto yy7;
				goto yy2;
			}
		}
	} else {
		if (yych <= '_') {
			if (yych <= '[') {
				if (yych <= '?') goto yy7;
				if (yych <= '@') goto yy2;
				if (yych <= 'Z') goto yy11;
				goto yy7;
			} else {
				if (yych == ']') goto yy7;
				if (yych <= '^') goto yy2;
				goto yy11;
			}
		} else {
			if (yych <= 'z') {
				if (yych <= '`') goto yy2;
				if (yych == 'c') goto yy14;
				goto yy11;
			} else {
				if (yych == '|') goto yy2;
				if (yych <= '}') goto yy7;
				goto yy2;
			}
		}
	}
yy1:
	++cur;
#line 41 "../src/parse/syntax_lexer.re"
	{ return STX_EOF; }
#line 130 "src/parse/syntax_lexer.cc"
yy2:
	++cur;
yy3:
#line 69 "../src/parse/syntax_lexer.re"
	{
        msg.error(tok_loc(), "unexpected character: '%c'", cur[-1]);
        return STX_error;
    }
#line 139 "src/parse/syntax_lexer.cc"
yy4:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yybm[0+yych] & 16) {
		goto yy4;
	}
#line 46 "../src/parse/syntax_lexer.re"
	{ goto start; }
#line 149 "src/parse/syntax_lexer.cc"
yy5:
	++cur;
#line 42 "../src/parse/syntax_lexer.re"
	{
        next_line();
        goto start;
    }
#line 157 "src/parse/syntax_lexer.cc"
yy6:
	++cur;
#line 67 "../src/parse/syntax_lexer.re"
	{ goto str; }
#line 162 "src/parse/syntax_lexer.cc"
yy7:
	++cur;
#line 68 "../src/parse/syntax_lexer.re"
	{ return cur[-1]; }
#line 167 "src/parse/syntax_lexer.cc"
yy8:
	yych = *++cur;
	if (yybm[0+yych] & 32) {
		goto yy10;
	}
	goto yy3;
yy9:
	yyaccept = 0;
	yych = *(mar = ++cur);
	if (yych == '/') goto yy15;
	goto yy3;
yy10:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yybm[0+yych] & 32) {
		goto yy10;
	}
#line 59 "../src/parse/syntax_lexer.re"
	{
        if (s_to_i32_unsafe(tok, cur, yylval->num)) {
            return STX_NUMBER;
        } else {
            msg.error(tok_loc(), "configuration value overflow");
            return STX_error;
        }
    }
#line 195 "src/parse/syntax_lexer.cc"
yy11:
	yyaccept = 1;
	mar = ++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
yy12:
	if (yybm[0+yych] & 64) {
		goto yy11;
	}
	if (yych <= 0x1F) {
		if (yych == '\t') {
			yyt1 = cur;
			goto yy17;
		}
	} else {
		if (yych <= ' ') {
			yyt1 = cur;
			goto yy17;
		}
		if (yych == '=') {
			yyt1 = cur;
			goto yy18;
		}
	}
yy13:
#line 55 "../src/parse/syntax_lexer.re"
	{
        yylval->str = newcstr(tok, cur, alc);
        return STX_NAME;
    }
#line 226 "src/parse/syntax_lexer.cc"
yy14:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych == 'o') goto yy19;
	goto yy12;
yy15:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yybm[0+yych] & 128) {
		goto yy15;
	}
	if (yych >= 0x01) goto yy5;
yy16:
	cur = mar;
	if (yyaccept == 0) {
		goto yy3;
	} else {
		goto yy13;
	}
yy17:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy17;
		goto yy16;
	} else {
		if (yych <= ' ') goto yy17;
		if (yych != '=') goto yy16;
	}
yy18:
	++cur;
	p = yyt1;
#line 51 "../src/parse/syntax_lexer.re"
	{
        yylval->str = newcstr(tok, p, alc);
        return STX_CONF;
    }
#line 266 "src/parse/syntax_lexer.cc"
yy19:
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych != 'd') goto yy12;
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych != 'e') goto yy12;
	yyaccept = 1;
	yych = *(mar = ++cur);
	if (yych != ':') goto yy12;
	yych = *++cur;
	if (yych <= '^') {
		if (yych <= '@') goto yy16;
		if (yych >= '[') goto yy16;
	} else {
		if (yych == '`') goto yy16;
		if (yych >= '{') goto yy16;
	}
yy20:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yych <= '9') {
		if (yych <= ' ') {
			if (yych == '\t') {
				yyt1 = cur;
				goto yy21;
			}
			if (yych <= 0x1F) goto yy16;
			yyt1 = cur;
		} else {
			if (yych <= ',') goto yy16;
			if (yych == '/') goto yy16;
			goto yy20;
		}
	} else {
		if (yych <= 'Z') {
			if (yych == '=') {
				yyt1 = cur;
				goto yy22;
			}
			if (yych <= '@') goto yy16;
			goto yy20;
		} else {
			if (yych <= '_') {
				if (yych <= '^') goto yy16;
				goto yy20;
			} else {
				if (yych <= '`') goto yy16;
				if (yych <= 'z') goto yy20;
				goto yy16;
			}
		}
	}
yy21:
	++cur;
	if (lim <= cur) YYFILL(1);
	yych = *cur;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy21;
		goto yy16;
	} else {
		if (yych <= ' ') goto yy21;
		if (yych != '=') goto yy16;
	}
yy22:
	++cur;
	p = yyt1;
#line 47 "../src/parse/syntax_lexer.re"
	{
        yylval->str = newcstr(tok, p, alc);
        return STX_CONF_CODE;
    }
#line 340 "src/parse/syntax_lexer.cc"
}
#line 73 "../src/parse/syntax_lexer.re"


str: 
#line 346 "src/parse/syntax_lexer.cc"
{
	uint8_t yych;
	if ((lim - cur) < 4) YYFILL(4);
	yych = *cur;
	if (yych <= '!') {
		if (yych <= 0x00) goto yy24;
		if (yych != '\n') goto yy26;
	} else {
		if (yych <= '"') goto yy27;
		if (yych == '\\') goto yy28;
		goto yy26;
	}
yy24:
	++cur;
yy25:
#line 92 "../src/parse/syntax_lexer.re"
	{
        tok = cur - 1;
        msg.error(tok_loc(), "syntax error in string literal");
        return STX_error;
    }
#line 368 "src/parse/syntax_lexer.cc"
yy26:
	++cur;
#line 86 "../src/parse/syntax_lexer.re"
	{ tmp_str += static_cast<char>(cur[-1]); goto str; }
#line 373 "src/parse/syntax_lexer.cc"
yy27:
	++cur;
#line 87 "../src/parse/syntax_lexer.re"
	{
        yylval->str = copystr(tmp_str, alc);
        tmp_str.clear();
        return STX_STRING;
    }
#line 382 "src/parse/syntax_lexer.cc"
yy28:
	yych = *(mar = ++cur);
	if (yych <= 'm') {
		if (yych <= '`') {
			if (yych <= '"') {
				if (yych <= '!') goto yy25;
			} else {
				if (yych == '\\') goto yy29;
				goto yy25;
			}
		} else {
			if (yych <= 'b') {
				if (yych <= 'a') goto yy30;
				goto yy31;
			} else {
				if (yych == 'f') goto yy32;
				goto yy25;
			}
		}
	} else {
		if (yych <= 't') {
			if (yych <= 'q') {
				if (yych <= 'n') goto yy33;
				goto yy25;
			} else {
				if (yych <= 'r') goto yy34;
				if (yych <= 's') goto yy25;
				goto yy35;
			}
		} else {
			if (yych <= 'v') {
				if (yych <= 'u') goto yy25;
				goto yy36;
			} else {
				if (yych == 'x') goto yy37;
				goto yy25;
			}
		}
	}
	++cur;
#line 77 "../src/parse/syntax_lexer.re"
	{ tmp_str += '"'; goto str; }
#line 425 "src/parse/syntax_lexer.cc"
yy29:
	++cur;
#line 76 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\\'; goto str; }
#line 430 "src/parse/syntax_lexer.cc"
yy30:
	++cur;
#line 78 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\a'; goto str; }
#line 435 "src/parse/syntax_lexer.cc"
yy31:
	++cur;
#line 79 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\b'; goto str; }
#line 440 "src/parse/syntax_lexer.cc"
yy32:
	++cur;
#line 80 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\f'; goto str; }
#line 445 "src/parse/syntax_lexer.cc"
yy33:
	++cur;
#line 81 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\n'; goto str; }
#line 450 "src/parse/syntax_lexer.cc"
yy34:
	++cur;
#line 82 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\r'; goto str; }
#line 455 "src/parse/syntax_lexer.cc"
yy35:
	++cur;
#line 83 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\t'; goto str; }
#line 460 "src/parse/syntax_lexer.cc"
yy36:
	++cur;
#line 84 "../src/parse/syntax_lexer.re"
	{ tmp_str += '\v'; goto str; }
#line 465 "src/parse/syntax_lexer.cc"
yy37:
	yych = *++cur;
	if (yych <= '/') goto yy38;
	if (yych <= '9') goto yy39;
yy38:
	cur = mar;
	goto yy25;
yy39:
	yych = *++cur;
	if (yych <= '/') goto yy38;
	if (yych >= ':') goto yy38;
	++cur;
#line 85 "../src/parse/syntax_lexer.re"
	{ tmp_str += static_cast<char>(unesc_hex(cur - 4, cur)); goto str; }
#line 480 "src/parse/syntax_lexer.cc"
}
#line 97 "../src/parse/syntax_lexer.re"

    UNREACHABLE();
    return STX_error; // unreachable
}

} // namespace re2c
