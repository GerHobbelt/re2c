api = [generic];
api_style = [freeform, functions];
jump_model = [goto_label, loop_switch];
target = [code, dot];

computed_goto = unsupported;
case_ranges = unsupported;
constants = upper_case;
char_literals = (encoding.ebcdic ? hexadecimal : symbolic);
semicolons = no;
label_indent = zero;
abort_requires_include = no;

code:var_defn_local = (have_init? name " := " init : "var " name " " type) nl;
code:var_defn_global = "var " name " " type " = " init nl;
code:array_defn = name " := []" type "{" init "}" nl;

code:type_int = "int";
code:type_uint = "uint";
code:type_yyctype = type;
code:type_yybm = "byte";

code:if_then_else =
    "if (" then_cond ") {" nl
        [then_stmt: indent then_stmt nl]
    (have_else_part? "} else " (have_else_cond? "if (" else_cond ") ") "{" nl
        [else_stmt: indent else_stmt nl])
    "}" nl;

code:switch =
    topindent "switch (" expr ") {" nl
    [case: case]
    topindent "}" nl;

code:switch_cases =
    [case{0:-2}: topindent case nl
        indent topindent "fallthrough" dedent nl]
    [case{-1}: topindent case nl]
        // `topindent` is needed in `oneline` case because re2c renders it in a special way
        indent (oneline ? topindent) [stmt: stmt] dedent;

code:switch_case_range = "case " [val{0}: val] [val{1:-1}: "," val] ":";

code:switch_case_default = "default:";

code:loop =
    (have_label? label ":" nl)
    "for {" nl
        [stmt: indent stmt nl]
    "}" nl;

code:cond_enum =
    "const (" nl
        [elem{0}:    indent elem " = " (jump_model.loop_switch ? init : "iota") nl]
        [elem{1:-1}: indent elem (jump_model.loop_switch ? " = " init) nl]
    ")" nl;

code:autogen_comment =
    "// Code generated by re2c"
    (version? " " version)
    (date? " on " date)
    ", DO NOT EDIT.";

code:line_directive = "//line \"" file "\":" line nl;

code:label = name;

code:abort_expr = "panic(\"internal lexer error\")";

code:yypeek_expr = (api.generic
    ? expr (api_style.functions ? "()")
    : "*" expr );
