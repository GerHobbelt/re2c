api = [generic];
api_style = [freeform, functions];
code_model = [goto_label, loop_switch, recursive_functions];
target = [code, dot];

computed_goto = unsupported;
case_ranges = unsupported;
constants = snake_case;
yyctype_literals = char;
semicolons = no;
abort_in_default_case = yes;
implicit_bool_conversion = no;
backtick_quoted_strings = yes;
standalone_single_quotes = no;

code:var = topindent (have_init? name " := " init : "var " name " " type) nl;

code:const = topindent "var " name " " type " = " init nl;

code:array =
    topindent name " := [" size "]" type "{" nl indent
        [row: topindent [elem{0:-2}: elem ", "] [elem{-1}: elem ","] nl]
    dedent topindent "}" nl;

code:type_int = "int";
code:type_uint = "uint";
// code:type_cond_enum
code:type_yybm = "byte";
// code:type_yytarget

code:if_then_else =
    [branch{0}: topindent "if (" cond ") {" nl
        indent [stmt: stmt] dedent]
    [branch{1:-1}: topindent "} else " (have_cond? "if (" cond ") ") "{" nl
        indent [stmt: stmt] dedent]
    topindent "}" nl;

code:switch =
    topindent "switch (" expr ") {" nl
    [case: case]
    topindent "}" nl;

code:switch_cases =
    [case{0:-2}: topindent case nl
        indent topindent "fallthrough" dedent nl]
    [case{-1}: topindent case nl]
        indent [stmt: stmt] dedent;

code:switch_case_range = "case " [val{0}: val] [val{1:-1}: "," val] ":";

code:switch_case_default = "default:";

code:loop =
    (have_label? label ":" nl)
    topindent "for {" nl
        indent [stmt: stmt] dedent
    topindent "}" nl;

// In Go `continue` statements have labels, use it to avoid ambiguity.
code:loop_label = "yyl";

code:enum =
    "const (" nl indent
        [elem{0}:    topindent elem " = " (have_init ? init : "iota") nl]
        [elem{1:-1}: topindent elem (have_init ? " = " init) nl]
    dedent ")" nl;

code:enum_elem = name;

code:fndef =
    topindent "func " name "("
        [arg{0:-2}: argtype " " argname ", "]
        [arg{-1}:   argtype " " argname]
    ")" (have_type ? " " type) " {" nl
        indent [stmt: stmt] dedent
    "}" nl;

code:fncall = name "(" [arg{0:-2}: arg ", "] [arg{-1}: arg] ")";

code:tailcall = topindent "return " name "(" [arg{0:-2}: arg ", "] [arg{-1}: arg] ")" nl;

code:recursive_functions = [fn: fndef nl];

code:fingerprint =
    "// Code generated by re2c"
    (have_version? " " version)
    (have_date? " on " date)
    ", DO NOT EDIT." nl;

code:line_info = "//line \"" file "\":" line nl;

code:abort = topindent "panic(\"internal lexer error\")" nl;

code:yyaccept = topindent var " = " num nl;

code:yydebug = topindent debug "(" state ", " char ")" nl;

code:yypeek = topindent char (code_model.recursive_functions ? " := " : " = ")
    peek (api_style.functions ? "()") nl;

code:yyskip = topindent skip (api_style.functions ? "()") nl;

code:yybackup = topindent backup (api_style.functions ? "()") nl;
