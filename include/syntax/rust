api = [generic];
api_style = [freeform, functions];
code_model = [loop_switch, recursive_functions];
target = [code, dot];

computed_goto = unsupported;
case_ranges = unsupported;
constants = upper_case;
yyctype_literals = hex;
semicolons = yes;
abort_in_default_case = yes;
implicit_bool_conversion = no;
backtick_quoted_strings = no;
standalone_single_quotes = yes;

code:var =
    // In Rust uninitialized variable is an error, but if the compiler is able to see
    // that all paths overwrite the initial value, it warns about unused assignments.
    (have_init? "" : topindent "#[allow(unused_assignments)]" nl)
    topindent "let mut " name " : " type " = " (have_init? init : "0") ";" nl;

code:const = topindent "const " name ": " type " = " init ";" nl;

// code:array

code:type_int = "isize";
code:type_uint = "usize";
code:type_cond_enum = (storable_state? "isize" : "usize");
// code:type_yybm
// code:type_yytarget

code:if_then_else =
    [branch{0}: topindent "if " cond " {" nl
        indent [stmt: stmt] dedent]
    [branch{1:-1}: topindent "} else " (have_cond? "if " cond " ") "{" nl
        indent [stmt: stmt] dedent]
    topindent "}" nl;

code:switch =
    topindent "match " expr " {" nl
        indent [case: case] dedent
    topindent "}" nl;

code:switch_cases =
    [case{0:-2}: topindent case " |" nl]
    [case{-1}:   topindent case " => {" nl
        indent [stmt: stmt] dedent
    topindent "}" nl];

code:switch_cases_oneline =
    [case{0:-2}: topindent case " |" nl]
    [case{-1}:   topindent case " => " [stmt: stmt]];

code:switch_case_range = [val{0}: val] (multival ? " ..= " [val{-1}: val]);

code:switch_case_default = "_";

code:loop =
    topindent (have_label? label ": ") "loop {" nl
        indent [stmt: stmt] dedent
    topindent "}" nl;

// In Rust `continue` statements have labels, use it to avoid ambiguity.
code:loop_label = "'yyl";

code:enum = [elem: topindent "const " elem ": " type " = " init ";" nl];

code:enum_elem = name;

code:fndef =
    topindent "fn " name "("
        [arg{0:-2}: argtype " " argname ", "]
        [arg{-1}:   argtype " " argname]
    ") ->" (have_type ? " " type) " {" nl
        indent [stmt: stmt] dedent
    "}" nl;

code:fncall = name "(" [arg{0:-2}: arg ", "] [arg{-1}: arg] ")";

code:tailcall = topindent name "(" [arg{0:-2}: arg ", "] [arg{-1}: arg] ")" nl;

code:recursive_functions = [fn: fndef nl];

code:fingerprint =
    "/* Generated by re2c" (have_version? " " version) (have_date? " on " date) " */" nl;

// No line directives in Rust: https://github.com/rust-lang/rfcs/issues/1862.
//code:line_info

code:abort = topindent "panic!(\"internal lexer error\");" nl;

code:yydebug = topindent debug "(" state ", " char ");" nl;

code:yypeek =
    topindent (code_model.recursive_functions ? "let mut ") char " = "
        (unsafe? "unsafe {" peek "}" : peek)
        (api_style.functions ? "()")
        ";" nl;

code:yyskip = topindent skip (api_style.functions ? "();") nl;

code:yybackup = topindent backup (api_style.functions ? "();") nl;
