api = [generic];
api_style = [freeform, functions];
jump_model = [loop_switch];
target = [code, dot];

computed_goto = unsupported;
case_ranges = unsupported;
constants = snake_case;
char_literals = (encoding.ebcdic ? hexadecimal : symbolic);
semicolons = yes;
label_indent = default;
abort_requires_include = no;

code:if_then_else =
    "if " then_cond " {" nl
        [then_stmt: indent then_stmt nl]
    (have_else_part? "} else " (have_else_cond? "if " else_cond " ") "{" nl
        [else_stmt: indent else_stmt nl])
    "}" nl;

code:var_defn_local =
    (have_init? "" : "#[allow(unused_assignments)]" nl)
    "let mut " name " : " type " = " (have_init? init : "0") nl;
code:var_defn_global = "const " name ": " type " = " init nl;
// code:array_defn = ??;

code:type_int = "isize";
code:type_uint = "usize";
code:type_yyctype = type;
// code:type_yybm = ??;

code:switch =
    "match " expr " {" nl
        [case: indent case]
    "}" nl;

code:switch_cases =
    [case{0:-2}: case " |" nl]
    [case{-1}: case " => {" nl
        [stmt: indent stmt nl]
    "}" nl];

code:switch_case_single = val;

code:switch_case_range = [val{0}: val] " ..= " [val{-1}: val];

code:switch_case_default = "_";

code:loop =
    (have_label? label ": ") "loop {" nl
        [stmt: indent stmt nl]
    "}" nl;

code:cond_enum = [elem: "const " elem ": " (storable_state? "isize" : "usize") " = " init ";" nl];

code:autogen_comment = "/* Generated by re2c" (version? " " version) (date? " on " date) " */";

// code:line_directive (no line directives in Rust)

code:label = "'" name;

// code:bitmap_check (bitmaps not supported in Rust)

code:abort_expr = "panic!(\"internal lexer error\")";

code:yypeek_expr = (unsafe? "unsafe { " expr " }" : expr) (api_style.functions ? "()");
