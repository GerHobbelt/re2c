(* Generated by re2c *)
#1 "ocaml/reuse/usedir.re"
(* re2ocaml $INPUT -o $OUTPUT *)

(* This example shows how to combine reusable re2c blocks: two blocks
   ('colors' and 'fish') are merged into one. The 'salmon' rule occurs
   in both blocks; the 'fish' block takes priority because it is used
   earlier. Default rule * occurs in all three blocks; the local (not
   inherited) definition takes priority. *)

type answer = Color | Fish | Dunno

type state = {
    str: string;
    mutable cur: int;
    mutable mar: int;
}

#20 "ocaml/reuse/usedir.re"


#25 "ocaml/reuse/usedir.re"



#27 "ocaml/reuse/usedir.ml"
let rec yy0 (st : state) : answer =
	let yych = st.str.[st.cur] in
	st.cur <- st.cur + 1;
	match yych with
		| 'e' -> (yy3 [@tailcall]) st
		| 'h' -> (yy4 [@tailcall]) st
		| 'm' -> (yy5 [@tailcall]) st
		| 'r' -> (yy6 [@tailcall]) st
		| 's' -> (yy7 [@tailcall]) st
		| _ -> (yy1 [@tailcall]) st

and yy1 (st : state) : answer =
	(yy2 [@tailcall]) st

and yy2 (st : state) : answer =
#38 "ocaml/reuse/usedir.re"
	Dunno
#45 "ocaml/reuse/usedir.ml"

and yy3 (st : state) : answer =
	st.mar <- st.cur;
	let yych = st.str.[st.cur] in
	match yych with
		| 'e' ->
			st.cur <- st.cur + 1;
			(yy8 [@tailcall]) st
		| _ -> (yy2 [@tailcall]) st

and yy4 (st : state) : answer =
	st.mar <- st.cur;
	let yych = st.str.[st.cur] in
	match yych with
		| 'a' ->
			st.cur <- st.cur + 1;
			(yy10 [@tailcall]) st
		| _ -> (yy2 [@tailcall]) st

and yy5 (st : state) : answer =
	st.mar <- st.cur;
	let yych = st.str.[st.cur] in
	match yych with
		| 'a' ->
			st.cur <- st.cur + 1;
			(yy11 [@tailcall]) st
		| _ -> (yy2 [@tailcall]) st

and yy6 (st : state) : answer =
	st.mar <- st.cur;
	let yych = st.str.[st.cur] in
	match yych with
		| 'e' ->
			st.cur <- st.cur + 1;
			(yy12 [@tailcall]) st
		| _ -> (yy2 [@tailcall]) st

and yy7 (st : state) : answer =
	st.mar <- st.cur;
	let yych = st.str.[st.cur] in
	match yych with
		| 'a' ->
			st.cur <- st.cur + 1;
			(yy13 [@tailcall]) st
		| _ -> (yy2 [@tailcall]) st

and yy8 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'l' ->
			st.cur <- st.cur + 1;
			(yy14 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy9 (st : state) : answer =
	st.cur <- st.mar;
	(yy2 [@tailcall]) st

and yy10 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'd' ->
			st.cur <- st.cur + 1;
			(yy15 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy11 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'g' ->
			st.cur <- st.cur + 1;
			(yy16 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy12 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'd' ->
			st.cur <- st.cur + 1;
			(yy17 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy13 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'l' ->
			st.cur <- st.cur + 1;
			(yy18 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy14 (st : state) : answer =
#24 "ocaml/reuse/usedir.re"
	Fish
#139 "ocaml/reuse/usedir.ml"

and yy15 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'd' ->
			st.cur <- st.cur + 1;
			(yy19 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy16 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'e' ->
			st.cur <- st.cur + 1;
			(yy20 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy17 (st : state) : answer =
#19 "ocaml/reuse/usedir.re"
	Color
#160 "ocaml/reuse/usedir.ml"

and yy18 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'm' ->
			st.cur <- st.cur + 1;
			(yy21 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy19 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'o' ->
			st.cur <- st.cur + 1;
			(yy22 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy20 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'n' ->
			st.cur <- st.cur + 1;
			(yy23 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy21 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'o' ->
			st.cur <- st.cur + 1;
			(yy24 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy22 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'c' ->
			st.cur <- st.cur + 1;
			(yy25 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy23 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 't' ->
			st.cur <- st.cur + 1;
			(yy26 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy24 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'n' ->
			st.cur <- st.cur + 1;
			(yy14 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy25 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'k' ->
			st.cur <- st.cur + 1;
			(yy14 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and yy26 (st : state) : answer =
	let yych = st.str.[st.cur] in
	match yych with
		| 'a' ->
			st.cur <- st.cur + 1;
			(yy17 [@tailcall]) st
		| _ -> (yy9 [@tailcall]) st

and lex (st : state) : answer =
	(yy0 [@tailcall]) st

#39 "ocaml/reuse/usedir.re"


let test(str, ans) =
    let st = {str = str; cur = 0; mar = 0}
    in if not (lex st = ans) then raise (Failure "error")

let main () =
    test("salmon", Fish);
    test("what?", Dunno)

let _ = main ()
