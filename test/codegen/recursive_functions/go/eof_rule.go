// Code generated by re2c, DO NOT EDIT.
//go:generate re2go $INPUT -o $OUTPUT --recursive-functions -i
package main

type State struct {
	str   string
	cur   uint
	mar   uint
	lim   uint
	count int
}


func yy0(st *State) int {
	yych := st.str[st.cur]
	switch (yych) {
	case ' ':
		st.cur += 1
		return yy3(st)
	case '\'':
		st.cur += 1
		return yy5(st)
	default:
		if (st.lim <= st.cur) {
			return yy10(st)
		} else {
			st.cur += 1
			return yy1(st)
		}
	}
}

func yy1(st *State) int {
	return yy2(st)
}

func yy2(st *State) int {
	{ return -1 }
}

func yy3(st *State) int {
	yych := st.str[st.cur]
	switch (yych) {
	case ' ':
		st.cur += 1
		return yy3(st)
	default:
		return yy4(st)
	}
}

func yy4(st *State) int {
	{ return do_lex(st) }
}

func yy5(st *State) int {
	st.mar = st.cur
	yych := st.str[st.cur]
	if (yych <= 0x00) {
		if (st.lim <= st.cur) {
			return yy2(st)
		} else {
			st.cur += 1
			return yy6(st)
		}
	} else {
		return yy7(st, yych)
	}
}

func yy6(st *State) int {
	yych := st.str[st.cur]
	return yy7(st, yych)
}

func yy7(st *State, yych byte) int {
	switch (yych) {
	case '\'':
		st.cur += 1
		return yy8(st)
	case '\\':
		st.cur += 1
		return yy9(st)
	default:
		if (st.lim <= st.cur) {
			return yy11(st)
		} else {
			st.cur += 1
			return yy6(st)
		}
	}
}

func yy8(st *State) int {
	{ st.count += 1; return do_lex(st) }
}

func yy9(st *State) int {
	yych := st.str[st.cur]
	if (yych <= 0x00) {
		if (st.lim <= st.cur) {
			return yy11(st)
		} else {
			st.cur += 1
			return yy6(st)
		}
	} else {
		st.cur += 1
		return yy6(st)
	}
}

func yy10(st *State) int {
	{ return st.count }
}

func yy11(st *State) int {
	st.cur = st.mar
	return yy2(st)
}

func do_lex(st *State) int {
	return yy0(st)
}



// Expects a null-terminated string.
func lex(str string) int {
	st := &State{
		str: str,
		cur: 0,
		mar: 0,
		lim: uint(len(str) - 1), // lim points at the terminating null
		count: 0}
	return do_lex(st)
}

func main() {
	assert_eq := func(x, y int) { if x != y { panic("error") } }
	assert_eq(lex("\000"), 0)
	assert_eq(lex("'qu\000tes' 'are' 'fine: \\'' \000"), 3)
	assert_eq(lex("'unterminated\\'\000"), -1)
}
