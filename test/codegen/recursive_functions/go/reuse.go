// Code generated by re2c, DO NOT EDIT.
//go:generate re2go $INPUT -o $OUTPUT --input-encoding utf8 --recursive-functions -i
package main

// This example supports multiple input encodings: UTF-8 and UTF-32.
// Both lexers are generated from the same rules block, and the use
// blocks add only encoding-specific configurations.



func yy0(str []uint8, cur uint, mar uint) int {
	yych := str[cur]
	cur += 1
	switch (yych) {
	case 0xE2:
		return yy3(str, cur, mar)
	default:
		return yy1(str, cur, mar)
	}
}

func yy1(str []uint8, cur uint, mar uint) int {
	return yy2(str, cur, mar)
}

func yy2(str []uint8, cur uint, mar uint) int {
	return 1;
}

func yy3(str []uint8, cur uint, mar uint) int {
	mar = cur
	yych := str[cur]
	switch (yych) {
	case 0x88:
		cur += 1
		return yy4(str, cur, mar)
	default:
		return yy2(str, cur, mar)
	}
}

func yy4(str []uint8, cur uint, mar uint) int {
	yych := str[cur]
	switch (yych) {
	case 0x80:
		cur += 1
		return yy6(str, cur, mar)
	default:
		return yy5(str, cur, mar)
	}
}

func yy5(str []uint8, cur uint, mar uint) int {
	cur = mar
	return yy2(str, cur, mar)
}

func yy6(str []uint8, cur uint, mar uint) int {
	yych := str[cur]
	switch (yych) {
	case 'x':
		cur += 1
		return yy7(str, cur, mar)
	default:
		return yy5(str, cur, mar)
	}
}

func yy7(str []uint8, cur uint, mar uint) int {
	yych := str[cur]
	switch (yych) {
	case ' ':
		cur += 1
		return yy8(str, cur, mar)
	default:
		return yy5(str, cur, mar)
	}
}

func yy8(str []uint8, cur uint, mar uint) int {
	yych := str[cur]
	switch (yych) {
	case 0xE2:
		cur += 1
		return yy9(str, cur, mar)
	default:
		return yy5(str, cur, mar)
	}
}

func yy9(str []uint8, cur uint, mar uint) int {
	yych := str[cur]
	switch (yych) {
	case 0x88:
		cur += 1
		return yy10(str, cur, mar)
	default:
		return yy5(str, cur, mar)
	}
}

func yy10(str []uint8, cur uint, mar uint) int {
	yych := str[cur]
	switch (yych) {
	case 0x83:
		cur += 1
		return yy11(str, cur, mar)
	default:
		return yy5(str, cur, mar)
	}
}

func yy11(str []uint8, cur uint, mar uint) int {
	yych := str[cur]
	switch (yych) {
	case 'y':
		cur += 1
		return yy12(str, cur, mar)
	default:
		return yy5(str, cur, mar)
	}
}

func yy12(str []uint8, cur uint, mar uint) int {
	return 0;
}

func lexUTF8(str []uint8, cur uint, mar uint) int {
	return yy0(str, cur, mar)
}




func yy13(str []uint32, cur uint, mar uint) int {
	yych := str[cur]
	cur += 1
	if (yych == 0x00002200) {
		return yy16(str, cur, mar)
	} else {
		return yy14(str, cur, mar)
	}
}

func yy14(str []uint32, cur uint, mar uint) int {
	return yy15(str, cur, mar)
}

func yy15(str []uint32, cur uint, mar uint) int {
	return 1;
}

func yy16(str []uint32, cur uint, mar uint) int {
	mar = cur
	yych := str[cur]
	if (yych == 'x') {
		cur += 1
		return yy17(str, cur, mar)
	} else {
		return yy15(str, cur, mar)
	}
}

func yy17(str []uint32, cur uint, mar uint) int {
	yych := str[cur]
	if (yych == ' ') {
		cur += 1
		return yy19(str, cur, mar)
	} else {
		return yy18(str, cur, mar)
	}
}

func yy18(str []uint32, cur uint, mar uint) int {
	cur = mar
	return yy15(str, cur, mar)
}

func yy19(str []uint32, cur uint, mar uint) int {
	yych := str[cur]
	if (yych == 0x00002203) {
		cur += 1
		return yy20(str, cur, mar)
	} else {
		return yy18(str, cur, mar)
	}
}

func yy20(str []uint32, cur uint, mar uint) int {
	yych := str[cur]
	if (yych == 'y') {
		cur += 1
		return yy21(str, cur, mar)
	} else {
		return yy18(str, cur, mar)
	}
}

func yy21(str []uint32, cur uint, mar uint) int {
	return 0;
}

func lexUTF32(str []uint32, cur uint, mar uint) int {
	return yy13(str, cur, mar)
}



func main() {
	assert_eq := func(x, y int) { if x != y { panic("error") } }
	assert_eq(lexUTF8([]uint8{0xe2, 0x88, 0x80, 0x78, 0x20, 0xe2, 0x88, 0x83, 0x79}, 0, 0), 0)
	assert_eq(lexUTF32([]uint32{0x2200, 0x78, 0x20, 0x2203, 0x79}, 0, 0), 0)
}
