/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT --recursive-functions

struct State<'a> {
    str: &'a [u8],
    lim: usize,
    cur: usize,
    mar: usize,
    count: isize
}

// Expect a null-terminated string.
fn lex(str: &[u8]) -> isize {
    let mut st = State {
        str: str,
        lim: str.len() - 1, // null-terminator not included
        cur: 0,
        mar: 0,
        count: 0
    };
    return lex_loop(&mut st);
}


fn yy0(_st: &mut State) -> isize {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x20 => {
			_st.cur += 1;
			yy3(_st)
		}
		0x27 => {
			_st.cur += 1;
			yy5(_st)
		}
		_ => {
			if _st.cur >= _st.lim {
				yy10(_st)
			} else {
				_st.cur += 1;
				yy1(_st)
			}
		}
	}
}

fn yy1(_st: &mut State) -> isize {
	yy2(_st)
}

fn yy2(_st: &mut State) -> isize {
	return -1;
}

fn yy3(_st: &mut State) -> isize {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x20 => {
			_st.cur += 1;
			yy3(_st)
		}
		_ => yy4(_st),
	}
}

fn yy4(_st: &mut State) -> isize {
	return lex_loop(_st);
}

fn yy5(_st: &mut State) -> isize {
	_st.mar = _st.cur;
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	if yych <= 0x00 {
		if _st.cur >= _st.lim {
			yy2(_st)
		} else {
			_st.cur += 1;
			yy6(_st)
		}
	} else {
		yy7(_st, yych)
	}
}

fn yy6(_st: &mut State) -> isize {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	yy7(_st, yych)
}

fn yy7(_st: &mut State, yych: u8) -> isize {
	match yych {
		0x27 => {
			_st.cur += 1;
			yy8(_st)
		}
		0x5C => {
			_st.cur += 1;
			yy9(_st)
		}
		_ => {
			if _st.cur >= _st.lim {
				yy11(_st)
			} else {
				_st.cur += 1;
				yy6(_st)
			}
		}
	}
}

fn yy8(_st: &mut State) -> isize {
	_st.count += 1; return lex_loop(_st);
}

fn yy9(_st: &mut State) -> isize {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	if yych <= 0x00 {
		if _st.cur >= _st.lim {
			yy11(_st)
		} else {
			_st.cur += 1;
			yy6(_st)
		}
	} else {
		_st.cur += 1;
		yy6(_st)
	}
}

fn yy10(_st: &mut State) -> isize {
	return _st.count;
}

fn yy11(_st: &mut State) -> isize {
	_st.cur = _st.mar;
	yy2(_st)
}

fn lex_loop(_st: &mut State) -> isize {
	yy0(_st)
}



fn main() {
    assert_eq!(lex(b"\0"), 0);
    assert_eq!(lex(b"'qu\0tes' 'are' 'fine: \\'' \0"), 3);
    assert_eq!(lex(b"'unterminated\\'\0"), -1);
}
