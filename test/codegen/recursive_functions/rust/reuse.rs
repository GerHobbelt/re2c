/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT --input-encoding utf8 --recursive-functions

// This example supports multiple input encodings: UTF-8 and UTF-32.
// Both lexers are generated from the same rules block, and the use
// blocks add only encoding-specific configurations.



fn yy0(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	_cur += 1;
	match yych {
		0xE2 => yy3(_str, _cur, _mar),
		_ => yy1(_str, _cur, _mar),
	}
}

fn yy1(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	yy2(_str, _cur, _mar)
}

fn yy2(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	{ return None; }
}

fn yy3(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	_mar = _cur;
	let yych = unsafe {*_str.get_unchecked(_cur)};
	match yych {
		0x88 => {
			_cur += 1;
			yy4(_str, _cur, _mar)
		}
		_ => yy2(_str, _cur, _mar),
	}
}

fn yy4(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	match yych {
		0x80 => {
			_cur += 1;
			yy6(_str, _cur, _mar)
		}
		_ => yy5(_str, _cur, _mar),
	}
}

fn yy5(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	_cur = _mar;
	yy2(_str, _cur, _mar)
}

fn yy6(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	match yych {
		0x78 => {
			_cur += 1;
			yy7(_str, _cur, _mar)
		}
		_ => yy5(_str, _cur, _mar),
	}
}

fn yy7(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	match yych {
		0x20 => {
			_cur += 1;
			yy8(_str, _cur, _mar)
		}
		_ => yy5(_str, _cur, _mar),
	}
}

fn yy8(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	match yych {
		0xE2 => {
			_cur += 1;
			yy9(_str, _cur, _mar)
		}
		_ => yy5(_str, _cur, _mar),
	}
}

fn yy9(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	match yych {
		0x88 => {
			_cur += 1;
			yy10(_str, _cur, _mar)
		}
		_ => yy5(_str, _cur, _mar),
	}
}

fn yy10(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	match yych {
		0x83 => {
			_cur += 1;
			yy11(_str, _cur, _mar)
		}
		_ => yy5(_str, _cur, _mar),
	}
}

fn yy11(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	match yych {
		0x79 => {
			_cur += 1;
			yy12(_str, _cur, _mar)
		}
		_ => yy5(_str, _cur, _mar),
	}
}

fn yy12(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	{ return Some(_cur); }
}

fn lex_utf8(_str: &[u8], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	yy0(_str, _cur, _mar)
}




fn yy13(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	_cur += 1;
	if yych == 0x00002200 {
		yy16(_str, _cur, _mar)
	} else {
		yy14(_str, _cur, _mar)
	}
}

fn yy14(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	yy15(_str, _cur, _mar)
}

fn yy15(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	{ return None; }
}

fn yy16(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	_mar = _cur;
	let yych = unsafe {*_str.get_unchecked(_cur)};
	if yych == 0x00000078 {
		_cur += 1;
		yy17(_str, _cur, _mar)
	} else {
		yy15(_str, _cur, _mar)
	}
}

fn yy17(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	if yych == 0x00000020 {
		_cur += 1;
		yy19(_str, _cur, _mar)
	} else {
		yy18(_str, _cur, _mar)
	}
}

fn yy18(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	_cur = _mar;
	yy15(_str, _cur, _mar)
}

fn yy19(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	if yych == 0x00002203 {
		_cur += 1;
		yy20(_str, _cur, _mar)
	} else {
		yy18(_str, _cur, _mar)
	}
}

fn yy20(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	let yych = unsafe {*_str.get_unchecked(_cur)};
	if yych == 0x00000079 {
		_cur += 1;
		yy21(_str, _cur, _mar)
	} else {
		yy18(_str, _cur, _mar)
	}
}

fn yy21(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	{ return Some(_cur); }
}

fn lex_utf32(_str: &[u32], mut _cur: usize, mut _mar: usize) -> Option<usize> {
	yy13(_str, _cur, _mar)
}



fn main() {
    let s8 = vec![0xe2, 0x88, 0x80, 0x78, 0x20, 0xe2, 0x88, 0x83, 0x79];
    assert_eq!(lex_utf8(&s8, 0, 0), Some(s8.len()));

    let s32 = vec![0x2200, 0x78, 0x20, 0x2203, 0x79];
    assert_eq!(lex_utf32(&s32, 0, 0), Some(s32.len()));
}
