/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT --recursive-functions -i

const YYMAXFILL: usize = 1;


struct State {
    buf: Vec<u8>,
    cur: usize,
    lim: usize,
    count: i32,
}


fn yy0(_st: &mut State) -> i32 {
	if _st.cur + 1 > _st.lim {
		return -1;
	}
	let yych = unsafe {*_st.buf.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x00 => yy1(_st),
		0x20 => yy3(_st),
		0x27 => yy5(_st),
		_ => yy2(_st),
	}
}

fn yy1(_st: &mut State) -> i32 {
	{ return if _st.cur + YYMAXFILL - 1 == _st.lim { _st.count } else { -1 }; }
}

fn yy2(_st: &mut State) -> i32 {
	{ return -1; }
}

fn yy3(_st: &mut State) -> i32 {
	if _st.cur + 1 > _st.lim {
		return -1;
	}
	let yych = unsafe {*_st.buf.get_unchecked(_st.cur)};
	match yych {
		0x20 => {
			_st.cur += 1;
			yy3(_st)
		}
		_ => yy4(_st),
	}
}

fn yy4(_st: &mut State) -> i32 {
	{ return lex(_st); }
}

fn yy5(_st: &mut State) -> i32 {
	if _st.cur + 1 > _st.lim {
		return -1;
	}
	let yych = unsafe {*_st.buf.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x27 => yy6(_st),
		0x5C => yy7(_st),
		_ => yy5(_st),
	}
}

fn yy6(_st: &mut State) -> i32 {
	{ _st.count += 1; return lex(_st); }
}

fn yy7(_st: &mut State) -> i32 {
	if _st.cur + 1 > _st.lim {
		return -1;
	}
	_st.cur += 1;
	yy5(_st)
}

fn lex(_st: &mut State) -> i32 {
	yy0(_st)
}



fn test(s: &[u8]) -> i32 {
    let lim = s.len() + YYMAXFILL;

    // Copy string to a buffer and add YYMAXFILL zero padding.
    let mut buf = Vec::with_capacity(lim);
    buf.extend(s.iter());
    buf.extend(vec![0; YYMAXFILL]);

    let mut st = State{buf: buf, cur: 0, lim: lim, count: 0};
    return lex(&mut st);
}

fn main() {
    assert_eq!(test(b""), 0);
    assert_eq!(test(b"'qu\0tes' 'are' 'fine: \\'' "), 3);
    assert_eq!(test(b"'unterminated\\'"), -1);
}
