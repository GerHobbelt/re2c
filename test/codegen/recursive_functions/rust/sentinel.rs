/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT --recursive-functions -i

struct State<'a> {
    str: &'a [u8],
    cur: usize,
    count: i32,
}


fn yy0(_st: &mut State) -> i32 {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x00 => yy1(_st),
		0x20 => yy3(_st),
		0x61 ..= 0x7A => yy5(_st),
		_ => yy2(_st),
	}
}

fn yy1(_st: &mut State) -> i32 {
	return _st.count;
}

fn yy2(_st: &mut State) -> i32 {
	return -1;
}

fn yy3(_st: &mut State) -> i32 {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x20 => {
			_st.cur += 1;
			yy3(_st)
		}
		_ => yy4(_st),
	}
}

fn yy4(_st: &mut State) -> i32 {
	return lex(_st);
}

fn yy5(_st: &mut State) -> i32 {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x61 ..= 0x7A => {
			_st.cur += 1;
			yy5(_st)
		}
		_ => yy6(_st),
	}
}

fn yy6(_st: &mut State) -> i32 {
	_st.count += 1; return lex(_st);
}

fn lex(_st: &mut State) -> i32 {
	yy0(_st)
}



fn main() {
    assert_eq!(lex(&mut State{str: b"\0", cur: 0, count: 0}), 0);
    assert_eq!(lex(&mut State{str: b"one two three\0", cur: 0, count: 0}), 3);
    assert_eq!(lex(&mut State{str: b"f0ur\0", cur: 0, count: 0}), -1);
}
