/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT --recursive-functions
#![allow(unused_braces)]

const ERROR: u64 = std::u32::MAX as u64 + 1; // overflow

macro_rules! maybe { // Convert the number from u64 to optional u32.
    ($n:expr) => { if $n < ERROR { Some($n as u32) } else { None } }
}

// Add digit with the given base, checking for overflow.
fn add(st: &mut State, offs: u8, base: u64) {
    let digit = unsafe { st.str.get_unchecked(st.cur - 1) } - offs;
    st.num = std::cmp::min(st.num * base + digit as u64, ERROR);
}

fn parse_u32(s: & [u8]) -> Option<u32> {
    let mut st = State {str: s, cur: 0, mar: 0, num: 0};
    parse_start(&mut st)
}

// Store u32 number in u64 during parsing to simplify overflow hadling.
struct State<'a> {
    str: &'a [u8],
    cur: usize,
    mar: usize,
    num: u64,
}




fn yy0(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 => yy2(_st),
		0x31 ..= 0x39 => yy4(_st),
		_ => yy1(_st),
	}
}

fn yy1(_st: &mut State) -> Option<u32> {
	None
}

fn yy2(_st: &mut State) -> Option<u32> {
	_st.mar = _st.cur;
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x42 |
		0x62 => {
			_st.cur += 1;
			yy5(_st)
		}
		0x58 |
		0x78 => {
			_st.cur += 1;
			yy7(_st)
		}
		_ => yy3(_st),
	}
}

fn yy3(_st: &mut State) -> Option<u32> {
	parse_oct(_st)
}

fn yy4(_st: &mut State) -> Option<u32> {
	_st.cur = (_st.cur as isize + -1) as usize;
	parse_dec(_st)
}

fn yy5(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x30 ..= 0x31 => {
			_st.cur += 1;
			yy8(_st)
		}
		_ => yy6(_st),
	}
}

fn yy6(_st: &mut State) -> Option<u32> {
	_st.cur = _st.mar;
	yy3(_st)
}

fn yy7(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x30 ..= 0x39 |
		0x41 ..= 0x46 |
		0x61 ..= 0x66 => {
			_st.cur += 1;
			yy9(_st)
		}
		_ => yy6(_st),
	}
}

fn yy8(_st: &mut State) -> Option<u32> {
	_st.cur = (_st.cur as isize + -1) as usize;
	parse_bin(_st)
}

fn yy9(_st: &mut State) -> Option<u32> {
	_st.cur = (_st.cur as isize + -1) as usize;
	parse_hex(_st)
}

fn parse_start(_st: &mut State) -> Option<u32> {
	yy0(_st)
}




fn yy10(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 ..= 0x31 => yy12(_st),
		_ => yy11(_st),
	}
}

fn yy11(_st: &mut State) -> Option<u32> {
	return maybe!(_st.num);
}

fn yy12(_st: &mut State) -> Option<u32> {
	add(_st, 48, 2); parse_bin(_st)
}

fn parse_bin(_st: &mut State) -> Option<u32> {
	yy10(_st)
}




fn yy13(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 ..= 0x37 => yy15(_st),
		_ => yy14(_st),
	}
}

fn yy14(_st: &mut State) -> Option<u32> {
	return maybe!(_st.num);
}

fn yy15(_st: &mut State) -> Option<u32> {
	add(_st, 48, 8); parse_oct(_st)
}

fn parse_oct(_st: &mut State) -> Option<u32> {
	yy13(_st)
}




fn yy16(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 ..= 0x39 => yy18(_st),
		_ => yy17(_st),
	}
}

fn yy17(_st: &mut State) -> Option<u32> {
	return maybe!(_st.num);
}

fn yy18(_st: &mut State) -> Option<u32> {
	add(_st, 48, 10); parse_dec(_st)
}

fn parse_dec(_st: &mut State) -> Option<u32> {
	yy16(_st)
}




fn yy19(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 ..= 0x39 => yy21(_st),
		0x41 ..= 0x46 => yy22(_st),
		0x61 ..= 0x66 => yy23(_st),
		_ => yy20(_st),
	}
}

fn yy20(_st: &mut State) -> Option<u32> {
	return maybe!(_st.num);
}

fn yy21(_st: &mut State) -> Option<u32> {
	add(_st, 48, 16); parse_hex(_st)
}

fn yy22(_st: &mut State) -> Option<u32> {
	add(_st, 55, 16); parse_hex(_st)
}

fn yy23(_st: &mut State) -> Option<u32> {
	add(_st, 87, 16); parse_hex(_st)
}

fn parse_hex(_st: &mut State) -> Option<u32> {
	yy19(_st)
}



fn main() {
    assert_eq!(parse_u32(b"\0"), None);
    assert_eq!(parse_u32(b"1234567890\0"), Some(1234567890));
    assert_eq!(parse_u32(b"0b1101\0"), Some(13));
    assert_eq!(parse_u32(b"0x7Fe\0"), Some(2046));
    assert_eq!(parse_u32(b"0644\0"), Some(420));
    assert_eq!(parse_u32(b"9999999999\0"), None);
}
